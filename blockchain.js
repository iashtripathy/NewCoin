const SHA256 = require('crypto-js/sha256');
//for generating public,private keys to sign the transaction
const EC = require('elliptic').ec;
//secp256k1 is the algorithm used in bitcoin.Instead we can use any other elliptic curve
const ec = new EC('secp256k1');

//class for our block
class Block {
    //transaction:has all the transactions waiting to be added to the blockchain
    //timestamp:tells us when the block is created.
    //data:this is the details about transaction
    //previousHash:holds the previous blocks hash value
    constructor(date, transactions, previousHash = '') {
            console.log(date);
            let month = date.getUTCMonth() + 1;
            let date1 = date.getUTCDate();
            let year = date.getUTCFullYear();
            this.timestamp = date1 + "/" + month + "/" + year;
            this.transactions = transactions;
            this.previousHash = previousHash;
            //hash:contains hash on this block
            this.hash = this.calculateHash();
            //nonce:for block difficulty
            this.nonce = 0;
        }
        //calculateHash:computes the hash of this block
        //this function will take all the properties of a block and then using sha256 generates this blocks hash value
    calculateHash() {
            return SHA256(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).toString();
        }
        //for blockdifficulty to mine our block
        //only the block is added to our blockchain if the difficulty standard is achieved
    mineBlock(difficulty) {
        while (this.hash.substring(0, difficulty) != Array(difficulty + 1).join("0")) {
            //nonce should be incremented before hash value is computed
            this.nonce++;
            this.hash = this.calculateHash();

        }
        console.log("Block mined successfully......and nonce value is: " + this.nonce);
    }
    hasValidTransactions() {
        for (const tx of this.transactions) {
            if (!tx.verifyIfTransactionIsCorrectlySigned()) {
                return false;
            }
        }
        return true;
    }
}

//class for our blockchain i.e:array of blocks
class Blockchain {
    //Blockchain class should always hold the entire chain of blocks
    constructor() {
            //chain is the array our all the blocks in our blockchain
            //pendingTransactions:Holds all the transactions that are waiting in the mempool to be added to the blockchain 
            //miningReward:amount paid to the miner for mining each block in the blockchain
            this.chain = [this.genesisBlock()];
            this.difficulty = 2;
            this.pendingTransactions = [];
            this.miningReward = 100;
        }
        //this should create our first block
        //Note:the first block always has a previousHash value = 0
    genesisBlock() {
            //Since it returns the first block the initial values should be send by us
            //returns an object holding our genesis block details
            return new Block(new Date(), "Genesis Block", "0");
        }
        //gives the latest block object in our blockchain
    getLatestBlock() {
        return this.chain[this.chain.length - 1];
    }
    miningPendingTransactions(miningRewardAddress) {
            //from address of mining reward is null because the miningreward amount is generated by the network itself
            //immediately after the block is mined the miner gets the transaction fee
            const rewardTx = new Transaction(null, miningRewardAddress, this.miningReward);
            this.pendingTransactions.push(rewardTx);
            /*here i am adding all the transactions waiting in the mempool to be put in a single block but inreal world
            this cannot happen because a block size in the blockchain netwrok cannot exceed
            1MB and the number of transactions waiting in the mempool are many*/
            let block = new Block(new Date(), this.pendingTransactions);
            block.previousHash = this.getLatestBlock().hash;
            block.mineBlock(this.difficulty);
            this.chain.push(block);
            this.pendingTransactions = [];
        }
        //for creating transactions
    addTransaction(transaction) {
        //console.log(transaction);
        if (!transaction.fromAddress || !transaction.toAddress) {
            throw new Error("Transaction must include fromAddress and toAddres");
        }
        if (!transaction.verifyIfTransactionIsCorrectlySigned()) {
            throw new Error("cannot add invalid transaction to chain");
        }
        this.pendingTransactions.push(transaction);
    }
    getBalanceOfAddress(address) {
        let balance = 0;
        /*Note:In blockchainNetwork everytime we need our balance the balance is computed looping the blocks right from the genesis block and then computing the balance
        as there are no fixed variable like the balance which holds our balance hence our balance 
        has to be recomputed evertime beginning from the very first transaction   */
        for (const block of this.chain) {
            for (const trans of block.transactions) {
                if (trans.fromAddress === address) {
                    /*if the address is fromAddress it means the address whose balance is tobe found
                    has given a money to some person hence deduct his balance by transaction amount*/
                    balance -= trans.amount;
                }
                if (trans.toAddress === address) {
                    balance += trans.amount;
                }

            }
        }
        return balance;
    }
    isChainValid() {
        for (let i = 1; i < this.chain.length; i++) {
            const currentBlock = this.chain[i];
            const previousBlock = this.chain[i - 1];
            if (!currentBlock.hasValidTransactions()) {
                return false;
            }
            /*if the data in the block changes once the block enters the blockchain then afterwards if any fields
            in the blockchain changes the hash of the block must change.Hence in this condition
            we check if the earlier hash value is same as present hash value of the block or not.If not the block is tampered 
            and hence the blockchain is invalid*/
            if (currentBlock.hash != currentBlock.calculateHash()) {
                console.log("hash:" + i + "\nhash:" + currentBlock.calculateHash());
                return false;
            }
            //this condition checks if the blocks are correctly connected in my blockchain network
            if (currentBlock.previousHash != previousBlock.hash) {
                console.log("previousHash:" + i);
                return false;
            }
        }
        return true;
    }
}

//This class holds the details about the transaction in the blocks in my blokchain network
class Transaction {
    constructor(fromAddress, toAddress, amount) {
            this.fromAddress = fromAddress;
            this.toAddress = toAddress;
            this.amount = amount;
        }
        /*Note:Every transaction has to be signed and signature has to checked for 
        whether it is valid or not*/
        /*We find the hash value combining all the transaction details and then we 
        only sign the hash value of the transaction using our private key*/
        //computes hash of the transaction
    calculateTransactionHash() {
            return SHA256(this.fromAddress + this.toAddress + this.amount).toString();
        }
        //this function is reponsible for signing our hash of the transaction
        //to sign any transaction we have to give our public and private key pair
        //We can only spent coins from the wallet whose private key is known to us
    signTransaction(signingKey) {
        if (signingKey.getPublic('hex') != this.fromAddress) {
            throw new Error("You cannot sign transactions for other valets");
        }
        const hashTx = this.calculateTransactionHash();
        //signing hash of our transaction
        const sig = signingKey.sign(hashTx, 'base64');
        //storing the signature in some format
        this.signature = sig.toDER('hex');
    }
    verifyIfTransactionIsCorrectlySigned() {
        /*the transactions which have the fromAdress field null are the ones which
        the blockchain network gives to the miner for mining a block.Hence these 
        transactions need not be signed*/
        if (this.fromAddress == null) {
            return true;
        }
        //if transaction is not signed then it is invalid transaction
        if (!this.signature || this.signature.length === 0) {
            throw new Error("No signature in this transaction");
        }
        /*If there is a signature then we have to verify that this transaction was signed 
        with proper key or not*/
        const pubKey = ec.keyFromPublic(this.fromAddress, 'hex');
        /*verify takes two arguments
        1.transactions hash value which has to be checked 
        2.the signature with which this has to be checked*/
        return pubKey.verify(this.calculateTransactionHash(), this.signature);
    }
}

module.exports.Blockchain = Blockchain;
module.exports.Transaction = Transaction;